---
alwaysApply: true
---

# Python Coding Rules for Web Automation

## 1. Python Basic Rules

### PEP8 Guidelines
- Follow PEP8 code style guide
- Use 4 spaces for indentation, no tabs
- Maximum line length of 100 characters (adjustable when necessary)
- Class names use PascalCase (e.g., `OrderPage`)
- Function and variable names use snake_case (e.g., `click_checkout_button`)
- Constants use UPPER_SNAKE_CASE (e.g., `MAX_WAIT_TIME`)
- Use blank lines to separate standard library, third-party, and local library imports
- Use meaningful variable names, avoid single-letter variables (except loop counters)

### DRY Principle (Don't Repeat Yourself)
- Avoid duplicate code, extract repeated logic into functions or methods
- Shared functionality should be placed in `BaseAction` or `BaseUtils`
- If the same logic is used in multiple places, create a shared method

### SOLID Principles
- **Single Responsibility**: Each class/function should have only one responsibility
- **Open/Closed**: Open for extension, closed for modification (use inheritance and interfaces)
- **Liskov Substitution**: Subclasses should be substitutable for their base classes
- **Interface Segregation**: Use small, focused interfaces
- **Dependency Inversion**: Depend on abstractions, not concrete implementations

## 2. SonarQube Quality Rules

### Cognitive Complexity
- Function cognitive complexity should be kept below 15
- If function complexity is too high, consider:
  - Split complex logic into multiple smaller functions
  - Use early returns to reduce nesting
  - Extract conditionals into separate methods
  - Use strategy pattern for complex branching logic

### Code Quality
- Avoid deep nesting (recommended max 3 levels)
- Use guard clauses to reduce nesting
- Avoid overly long methods (recommended max 50 lines)
- Avoid overly long parameter lists (recommended max 5 parameters)

```python
# ❌ Bad: Too complex
def complex_function(self):
    if condition1:
        if condition2:
            if condition3:
                if condition4:
                    # do something

# ✅ Good: Use early return
def complex_function(self):
    if not condition1:
        return
    if not condition2:
        return
    if not condition3:
        return
    # do something
```

## 3. Locator Rules

### Using Playwright + Selector Conversion
- **Author locators in Playwright format**, then convert to Selenium tuple at the locator layer
- Use `utils.locator_converter.selector()` inside locator classes, not in page objects or tests
- Supported formats:
  - `page.locator('[data-testid="button"]')`
  - `page.get_by_test_id('button')`
  - `'[data-testid="button"]'` (direct CSS selector)

```python
from utils.locator_converter import selector


class OrderPageLocators:
    """Playwright selectors converted once for Selenium usage."""

    CHECKOUT_BUTTON = selector('page.locator("[data-testid=\\"checkout-button\\"]")')
    DELIVERY_OPTION = selector('page.get_by_test_id("delivery-option")')
    ADDRESS_INPUT = selector('[data-testid="address-input"]')
```

### Locator Best Practices
- Store locators in dedicated classes under the `locators/` package
- Keep locator names descriptive and grouped by page
- Prefer stable attributes such as `data-testid`
- Avoid fragile locators (e.g., brittle XPath, overly complex CSS selectors)

## 4. Page Object Pattern Rules

### Inherit from BaseAction
- All Page Object classes must inherit from `BaseAction`
- Fully utilize `BaseAction` provided base methods, avoid duplicate implementations

### Using BaseAction Methods
- **Wait for elements**: Use `wait_for_element_visible()`, `wait_for_element_clickable()`, etc.
- **Click elements**: Use `click_element()`, which includes error handling and JavaScript fallback
- **Input text**: Use `send_keys_to_element()`, which includes clearing logic
- **Check elements**: Use `is_element_visible()`, `is_element_clickable()`, etc.

```python
from pages.base_actions.base_action import BaseAction
from locators.order_page_locators import OrderPageLocators


class OrderPage(BaseAction):
    def open(self):
        self.open_url(url=self.config.BASE_URL)

    def wait_for_loaded(self):
        self.wait_for_element_visible(*OrderPageLocators.RESTAURANT_HEADING)
        self.wait_for_element_visible(*OrderPageLocators.DELIVERY_PROMPT)

    def click_checkout(self):
        self.click_element(*OrderPageLocators.CHECKOUT_BUTTON)

    def input_address(self, address):
        self.send_keys_to_element(*OrderPageLocators.ADDRESS_INPUT, address)

    def is_confirm_button_enabled(self):
        return self.wait_for_element_clickable(*OrderPageLocators.CONFIRM_BUTTON, timeout=5)
```

### Page Object Method Design
- Each method should perform only one clear action
- Methods should return meaningful values (e.g., return page objects to support method chaining)
- Use clear error messages for easier debugging

## 5. Test Writing Rules

### Step Definitions & Test Structure
- Define BDD steps alongside the test module (e.g., `tests/test_order_page.py`)
- Instantiate the required Page Object inside each step function; do not rely on returning it from previous steps
- Keep step functions concise and delegate UI logic to Page Objects
- When parsing dynamic values, continue使用 `parsers.parse()` 或 `parsers.cfparse()`（依情境需要）
- Include scenario comments (e.g., `# Scenario: ... @tags`) above step functions to improve readability
- Name step functions after what they verify/do (e.g., `verify_order_page_loaded`) rather than copying the step text verbatim

```python
from pytest_bdd import given, scenarios, then
from pages.order_page import OrderPage

scenarios("features/order_page.feature")


@given("I open the Food Ordering company page")
def open_food_ordering_page(browser):
    page = OrderPage(browser)
    page.open()
    page.wait_for_loaded()


# Scenario: Open Food Ordering company page @successful_order_page_load @order_page
@then("the page should display the company's food ordering options and relevant information")
def verify_order_page_content(browser):
    page = OrderPage(browser)
    assert page.get_restaurant_name().strip()
    assert page.is_delivery_prompt_visible()
```

## 6. Error Handling

### Exception Handling
- Use explicit exception types, avoid bare `except:`
- In Page Object methods, let exceptions propagate upward, handled by test layer
- Use waiting methods provided by `BaseAction`, they already include exception handling

```python
# ✅ Good: Explicit exception handling
try:
    self.wait_for_element_visible(*self.button)
except TimeoutException:
    raise ElementNotFoundError(f"Button not found: {self.button}")
```

## 7. Comments and Documentation

### Docstring
- All public methods should have docstrings
- Use Google-style docstrings
- Include parameters, return values, and possible exceptions

```python
def click_checkout_button(self):
    """
    Clicks the checkout button on the page.
    
    Raises:
        TimeoutException: If the checkout button is not found or not clickable within timeout.
    """
    self.click_element(*self.checkout_button)
```

## 8. Test Data Management

### Test Data
- Use fixed test data (e.g., email, phone number) that meets format requirements
- Avoid hardcoding, place test data in configuration files or fixtures
- Use meaningful test data for easy identification and debugging

## 9. Code Organization

### File Structure
- Each Page Object should correspond to one file
- Step definitions should be organized by feature modules (e.g., `order_placement_steps.py`)
- Shared functionality should be in `base_actions` or `utils`

### Import Order
1. Standard library
2. Third-party libraries
3. Local application libraries

```python
# Standard library
import time
from datetime import datetime

# Third-party libraries
from selenium.webdriver.common.by import By
from pytest_bdd import given, when, then

# Local libraries
from pages.base_actions.base_action import BaseAction
from utils.locator_converter import selector
```

## 10. Summary Checklist

Before submitting code, ensure:
- [ ] Follow PEP8 guidelines
- [ ] Function cognitive complexity < 15
- [ ] Use `selector()` function to convert Playwright locators
- [ ] Page Objects inherit from `BaseAction` and use its methods
- [ ] Step definitions use parser to pass parameters
- [ ] All public methods have docstrings
- [ ] No duplicate code
- [ ] Error handling is appropriate
- [ ] Test data meets format requirements

