---
alwaysApply: true
---

# Python Coding Rules for Web Automation

## 1. Python Basic Rules

### PEP8 Guidelines
- Follow PEP8 code style guide
- Use 4 spaces for indentation, no tabs
- Maximum line length of 100 characters (adjustable when necessary)
- Class names use PascalCase (e.g., `OrderPage`)
- Function and variable names use snake_case (e.g., `click_checkout_button`)
- Constants use UPPER_SNAKE_CASE (e.g., `MAX_WAIT_TIME`)
- Use blank lines to separate standard library, third-party, and local library imports
- Use meaningful variable names, avoid single-letter variables (except loop counters)

### DRY Principle (Don't Repeat Yourself)
- Avoid duplicate code, extract repeated logic into functions or methods
- Shared functionality should be placed in `BaseAction` or `BaseUtils`
- If the same logic is used in multiple places, create a shared method

### SOLID Principles
- **Single Responsibility**: Each class/function should have only one responsibility
- **Open/Closed**: Open for extension, closed for modification (use inheritance and interfaces)
- **Liskov Substitution**: Subclasses should be substitutable for their base classes
- **Interface Segregation**: Use small, focused interfaces
- **Dependency Inversion**: Depend on abstractions, not concrete implementations

## 2. SonarQube Quality Rules

### Cognitive Complexity
- Function cognitive complexity should be kept below 15
- If function complexity is too high, consider:
  - Split complex logic into multiple smaller functions
  - Use early returns to reduce nesting
  - Extract conditionals into separate methods
  - Use strategy pattern for complex branching logic

### Code Quality
- Avoid deep nesting (recommended max 3 levels)
- Use guard clauses to reduce nesting
- Avoid overly long methods (recommended max 50 lines)
- Avoid overly long parameter lists (recommended max 5 parameters)

```python
# ❌ Bad: Too complex
def complex_function(self):
    if condition1:
        if condition2:
            if condition3:
                if condition4:
                    # do something

# ✅ Good: Use early return
def complex_function(self):
    if not condition1:
        return
    if not condition2:
        return
    if not condition3:
        return
    # do something
```

## 3. Locator Rules

### Using Playwright + Selector Conversion
- **Prioritize Playwright locator format**, then use `selector()` function to convert to Selenium format
- Use `utils.locator_converter.selector()` function for conversion
- Supported formats:
  - `page.locator('[data-testid="button"]')`
  - `page.get_by_test_id('button')`
  - `'[data-testid="button"]'` (direct CSS selector)

```python
from utils.locator_converter import selector

class OrderPage(BaseAction):
    def __init__(self, driver):
        super().__init__(driver)
        # Use Playwright format locator, then convert with selector()
        self.checkout_button = selector('page.locator("[data-testid=\\"checkout-button\\"]")')
        self.delivery_option = selector('page.get_by_test_id("delivery-option")')
        self.address_input = selector('[data-testid="address-input"]')
    
    def click_checkout(self):
        self.click_element(*self.checkout_button)
```

### Locator Best Practices
- Prioritize using `data-testid` attribute for element location
- Avoid fragile locators (e.g., absolute XPath, overly complex CSS selectors)
- Define locators in `__init__` method for easy maintenance and reuse
- Use descriptive locator variable names

## 4. Page Object Pattern Rules

### Inherit from BaseAction
- All Page Object classes must inherit from `BaseAction`
- Fully utilize `BaseAction` provided base methods, avoid duplicate implementations

### Using BaseAction Methods
- **Wait for elements**: Use `wait_for_element_visible()`, `wait_for_element_clickable()`, etc.
- **Click elements**: Use `click_element()`, which includes error handling and JavaScript fallback
- **Input text**: Use `send_keys_to_element()`, which includes clearing logic
- **Check elements**: Use `is_element_visible()`, `is_element_clickable()`, etc.

```python
from pages.base_actions.base_action import BaseAction
from utils.locator_converter import selector

class CheckoutPage(BaseAction):
    def __init__(self, driver):
        super().__init__(driver)
        self.confirm_button = selector('page.locator("[data-testid=\\"confirm-button\\"]")')
        self.address_field = selector('[data-testid="address-field"]')
    
    def click_confirm(self):
        # Use BaseAction's click_element, includes waiting and error handling
        self.click_element(*self.confirm_button)
    
    def input_address(self, address):
        # Use BaseAction's send_keys_to_element, includes clearing logic
        self.send_keys_to_element(*self.address_field, address)
    
    def is_confirm_button_enabled(self):
        # Use BaseAction's wait methods to ensure stability
        return self.wait_for_element_clickable(*self.confirm_button, timeout=5)
```

### Page Object Method Design
- Each method should perform only one clear action
- Methods should return meaningful values (e.g., return page objects to support method chaining)
- Use clear error messages for easier debugging

## 5. Test Writing Rules

### Using Parser to Pass Values
- Use `parsers.parse()` or `parsers.cfparse()` in step definitions to parse parameters
- For table data, use `parsers.parse()` with `TypeParser`
- Support parameterized tests to improve test maintainability

```python
from pytest_bdd import given, when, then, parsers
from pages.order_page import OrderPage
from pages.checkout_page import CheckoutPage

@given(parsers.parse('I have opened the Food Ordering page'))
def open_food_ordering_page(browser):
    order_page = OrderPage(browser)
    order_page.open_url()

@when(parsers.parse('I select "{option}"'))
def select_delivery_option(browser, option):
    order_page = OrderPage(browser)
    order_page.select_delivery_option(option)

@when(parsers.parse('I input postal code "{postal_code}" at address picker'))
def input_postal_code(browser, postal_code):
    order_page = OrderPage(browser)
    order_page.input_postal_code(postal_code)

@when(parsers.cfparse('I input credit card information:\n{credit_card_data}', 
                      extra_types=dict(credit_card_number=str, cardholder_name=str, 
                                      expiration_date=str, security_code=str)))
def input_credit_card_info(browser, credit_card_data):
    checkout_page = CheckoutPage(browser)
    checkout_page.input_credit_card(
        card_number=credit_card_data['Credit Card Number'],
        cardholder_name=credit_card_data['Cardholder Name'],
        expiration_date=credit_card_data['Expiration Date'],
        security_code=credit_card_data['Security Code']
    )
```

### Step Definitions Best Practices
- One step definition should correspond to one clear operation
- Use Page Object methods, avoid directly manipulating driver in step definitions
- Keep step definitions concise, complex logic should be in Page Objects
- Use appropriate fixtures (e.g., `browser`) to manage test state

```python
# ❌ Bad: Directly manipulate driver in step definition
@when('I click checkout button')
def click_checkout(browser):
    browser.find_element(By.CSS_SELECTOR, '[data-testid="checkout"]').click()

# ✅ Good: Use Page Object
@when('I click checkout button')
def click_checkout(browser):
    checkout_page = CheckoutPage(browser)
    checkout_page.click_checkout()
```

## 6. Error Handling

### Exception Handling
- Use explicit exception types, avoid bare `except:`
- In Page Object methods, let exceptions propagate upward, handled by test layer
- Use waiting methods provided by `BaseAction`, they already include exception handling

```python
# ✅ Good: Explicit exception handling
try:
    self.wait_for_element_visible(*self.button)
except TimeoutException:
    raise ElementNotFoundError(f"Button not found: {self.button}")
```

## 7. Comments and Documentation

### Docstring
- All public methods should have docstrings
- Use Google-style docstrings
- Include parameters, return values, and possible exceptions

```python
def click_checkout_button(self):
    """
    Clicks the checkout button on the page.
    
    Raises:
        TimeoutException: If the checkout button is not found or not clickable within timeout.
    """
    self.click_element(*self.checkout_button)
```

## 8. Test Data Management

### Test Data
- Use fixed test data (e.g., email, phone number) that meets format requirements
- Avoid hardcoding, place test data in configuration files or fixtures
- Use meaningful test data for easy identification and debugging

## 9. Code Organization

### File Structure
- Each Page Object should correspond to one file
- Step definitions should be organized by feature modules (e.g., `order_placement_steps.py`)
- Shared functionality should be in `base_actions` or `utils`

### Import Order
1. Standard library
2. Third-party libraries
3. Local application libraries

```python
# Standard library
import time
from datetime import datetime

# Third-party libraries
from selenium.webdriver.common.by import By
from pytest_bdd import given, when, then

# Local libraries
from pages.base_actions.base_action import BaseAction
from utils.locator_converter import selector
```

## 10. Summary Checklist

Before submitting code, ensure:
- [ ] Follow PEP8 guidelines
- [ ] Function cognitive complexity < 15
- [ ] Use `selector()` function to convert Playwright locators
- [ ] Page Objects inherit from `BaseAction` and use its methods
- [ ] Step definitions use parser to pass parameters
- [ ] All public methods have docstrings
- [ ] No duplicate code
- [ ] Error handling is appropriate
- [ ] Test data meets format requirements
